from pathlib import Path

import numpy as np
import pandas as pd

SUPPORTED_MODELS = ["prophet", "ets", "sarima", "tbats", "neuralprophet", "orbit"]


def _prepare_frame(rows: list[dict]) -> pd.DataFrame:
    frame = pd.DataFrame(rows)
    if "date" not in frame.columns or "value" not in frame.columns:
        raise ValueError("数据列必须包含 date/value")

    frame = frame.rename(columns={"date": "ds", "value": "y"})
    frame["ds"] = pd.to_datetime(frame["ds"], format="%Y-%m-%d", errors="coerce")
    frame["y"] = pd.to_numeric(frame["y"], errors="coerce")
    frame = frame.dropna(subset=["ds", "y"]).sort_values("ds").reset_index(drop=True)

    if frame.shape[0] < 3:
        raise ValueError("有效数据不足，至少需要 3 条")
    return frame


def _build_full_dates(frame: pd.DataFrame, periods: int) -> pd.DatetimeIndex:
    last_date = frame["ds"].max()
    future_dates = pd.date_range(last_date + pd.Timedelta(days=1), periods=periods, freq="D")
    history_dates = pd.DatetimeIndex(frame["ds"].tolist())
    return history_dates.append(future_dates)


def _as_output(dates: pd.DatetimeIndex, yhat: np.ndarray, lower: np.ndarray | None = None, upper: np.ndarray | None = None) -> list[dict]:
    records = []
    for idx, dt in enumerate(dates):
        pred = float(yhat[idx])
        low = float(lower[idx]) if lower is not None else pred
        high = float(upper[idx]) if upper is not None else pred
        records.append(
            {
                "date": dt.strftime("%Y-%m-%d"),
                "yhat": pred,
                "yhat_lower": low,
                "yhat_upper": high,
            }
        )
    return records


def _ensure_prophet_cmdstan_makefile() -> None:
    import prophet

    if prophet.__file__ is None:
        return
    prophet_pkg_dir = Path(prophet.__file__).resolve().parent
    makefile = prophet_pkg_dir / "stan_model" / "cmdstan-2.33.1" / "makefile"
    if not makefile.exists():
        makefile.write_text("# generated by TrendForecasting\n", encoding="utf-8")


def forecast_prophet(frame: pd.DataFrame, periods: int) -> list[dict]:
    from prophet import Prophet

    _ensure_prophet_cmdstan_makefile()
    model = Prophet(seasonality_mode="additive", interval_width=0.8)
    model.fit(frame[["ds", "y"]])
    future = model.make_future_dataframe(periods=periods, freq="D", include_history=True)
    pred = model.predict(future)
    output = pred[["ds", "yhat", "yhat_lower", "yhat_upper"]].copy()
    output["ds"] = output["ds"].dt.strftime("%Y-%m-%d")
    return [
        {
            "date": row["ds"],
            "yhat": float(row["yhat"]),
            "yhat_lower": float(row["yhat_lower"]),
            "yhat_upper": float(row["yhat_upper"]),
        }
        for row in output.to_dict(orient="records")
    ]


def forecast_ets(frame: pd.DataFrame, periods: int) -> list[dict]:
    from statsmodels.tsa.holtwinters import ExponentialSmoothing

    y = frame["y"].to_numpy(dtype=float)
    seasonal_periods = 7 if len(y) >= 14 else None
    model = ExponentialSmoothing(
        y,
        trend="add",
        seasonal="add" if seasonal_periods else None,
        seasonal_periods=seasonal_periods,
        damped_trend=True,
    )
    fitted = model.fit(optimized=True)
    fitted_values = np.asarray(fitted.fittedvalues, dtype=float)
    future = np.asarray(fitted.forecast(periods), dtype=float)
    all_values = np.concatenate([fitted_values, future])
    sigma = float(np.std(y - fitted_values)) if len(y) > 3 else 0.0
    lower = all_values - 1.28 * sigma
    upper = all_values + 1.28 * sigma
    return _as_output(_build_full_dates(frame, periods), all_values, lower, upper)


def forecast_sarima(frame: pd.DataFrame, periods: int) -> list[dict]:
    from statsmodels.tsa.statespace.sarimax import SARIMAX

    y = frame["y"].to_numpy(dtype=float)
    seasonal_order = (1, 1, 1, 7) if len(y) >= 21 else (0, 0, 0, 0)
    model = SARIMAX(y, order=(1, 1, 1), seasonal_order=seasonal_order, enforce_stationarity=False, enforce_invertibility=False)
    fitted = model.fit(disp=False)
    pred = fitted.get_prediction(start=0, end=len(y) + periods - 1)
    mean = np.asarray(pred.predicted_mean, dtype=float)
    conf = pred.conf_int(alpha=0.2)
    lower = np.asarray(conf[:, 0], dtype=float)
    upper = np.asarray(conf[:, 1], dtype=float)
    return _as_output(_build_full_dates(frame, periods), mean, lower, upper)


def forecast_tbats(frame: pd.DataFrame, periods: int) -> list[dict]:
    from tbats import TBATS

    y = frame["y"].to_numpy(dtype=float)
    estimator = TBATS(seasonal_periods=[7] if len(y) >= 14 else None)
    fitted = estimator.fit(y)
    history = np.asarray(getattr(fitted, "y_hat", y), dtype=float)
    future = np.asarray(fitted.forecast(steps=periods), dtype=float)
    all_values = np.concatenate([history, future])
    sigma = float(np.std(y - history[: len(y)])) if len(y) > 3 else 0.0
    lower = all_values - 1.28 * sigma
    upper = all_values + 1.28 * sigma
    return _as_output(_build_full_dates(frame, periods), all_values, lower, upper)


def forecast_neuralprophet(frame: pd.DataFrame, periods: int) -> list[dict]:
    from neuralprophet import NeuralProphet

    train_df = frame[["ds", "y"]].copy()
    model = NeuralProphet()
    model.fit(train_df, freq="D", progress="off")
    future = model.make_future_dataframe(train_df, periods=periods)
    pred = model.predict(future)
    yhat_col = next((col for col in pred.columns if col.startswith("yhat")), "yhat1")
    yhat = pd.to_numeric(pred[yhat_col], errors="coerce").to_numpy(dtype=float)
    yhat = np.nan_to_num(yhat, nan=np.nanmean(yhat))
    lower = yhat
    upper = yhat
    return _as_output(pd.DatetimeIndex(pred["ds"]), yhat, lower, upper)


def forecast_orbit(frame: pd.DataFrame, periods: int) -> list[dict]:
    from orbit.models import DLT

    train_df = frame.rename(columns={"y": "value"})[["ds", "value"]].copy()
    model = DLT(response_col="value", date_col="ds")
    model.fit(train_df)

    future_dates = _build_full_dates(frame, periods)
    pred_df = pd.DataFrame({"ds": future_dates})
    pred = model.predict(pred_df)
    values = pd.to_numeric(pred["prediction"], errors="coerce").to_numpy(dtype=float)
    values = np.nan_to_num(values, nan=np.nanmean(values))
    return _as_output(future_dates, values, values, values)


MODEL_RUNNERS = {
    "prophet": forecast_prophet,
    "ets": forecast_ets,
    "sarima": forecast_sarima,
    "tbats": forecast_tbats,
    "neuralprophet": forecast_neuralprophet,
    "orbit": forecast_orbit,
}


def run_forecast(rows: list[dict], periods: int, models: list[str] | None = None) -> dict:
    if len(rows) < 3:
        raise ValueError("rows 至少 3 条")

    frame = _prepare_frame(rows)
    selected = models or ["prophet"]

    history = [
        {"date": row["ds"].strftime("%Y-%m-%d"), "value": float(row["y"])}
        for _, row in frame.iterrows()
    ]

    forecasts_by_model: dict[str, list[dict]] = {}
    failed_models: dict[str, str] = {}

    for model_name in selected:
        runner = MODEL_RUNNERS.get(model_name)
        if runner is None:
            failed_models[model_name] = "模型未注册"
            continue
        try:
            forecasts_by_model[model_name] = runner(frame, periods)
        except Exception as exc:
            failed_models[model_name] = str(exc)

    if not forecasts_by_model:
        raise ValueError(f"所有模型均失败: {failed_models}")

    primary_model = selected[0] if selected[0] in forecasts_by_model else next(iter(forecasts_by_model.keys()))

    return {
        "history": history,
        "primary_model": primary_model,
        "forecast": forecasts_by_model[primary_model],
        "forecasts_by_model": forecasts_by_model,
        "failed_models": failed_models,
    }
